{"version":3,"sources":["private/context.js","private/context.ts"],"names":[],"mappings":"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","file":"private/context.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Loc', 'op/Op', 'source-map/dist/source-map.min', './util'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Loc_1 = require('esast/lib/Loc');\n    var Op_1 = require('op/Op');\n    var source_map_min_1 = require('source-map/dist/source-map.min');\n    var util_1 = require('./util');\n    let strOut;\n    let indentAmount;\n    let indentStr;\n    let usingSourceMaps;\n    let curAst;\n    let inFilePath;\n    let sourceMap;\n    let outLine;\n    let outColumn;\n    let lastMappedAst;\n    let ugly;\n    function setUp(options) {\n        ugly = Boolean(options.ugly);\n        indentAmount = 0;\n        setIndent();\n        strOut = '';\n        usingSourceMaps = false;\n    }\n    exports.setUp = setUp;\n    function setUpSourceMap(inPath, outPath) {\n        usingSourceMaps = true;\n        inFilePath = inPath;\n        sourceMap = new source_map_min_1.SourceMapGenerator({ file: outPath });\n        outLine = Loc_1.Pos.start.line;\n        outColumn = Loc_1.Pos.start.column;\n        lastMappedAst = null;\n    }\n    exports.setUpSourceMap = setUpSourceMap;\n    function finish() {\n        const _ = strOut;\n        freeMemory();\n        return _;\n    }\n    exports.finish = finish;\n    function finishWithSourceMap() {\n        const _ = { code: strOut, sourceMap: sourceMap.toJSON() };\n        freeMemory();\n        return _;\n    }\n    exports.finishWithSourceMap = finishWithSourceMap;\n    function freeMemory() {\n        strOut = inFilePath = sourceMap = curAst = lastMappedAst = null;\n    }\n    function setAst(_) {\n        curAst = _;\n    }\n    exports.setAst = setAst;\n    function o(str) {\n        strOut = strOut + str;\n        if (usingSourceMaps)\n            mapStr(str);\n    }\n    exports.o = o;\n    function oWithNewlines(str) {\n        const parts = str.split('\\n');\n        o(parts[0]);\n        for (let i = 1; i < parts.length; i = i + 1) {\n            strOut = `${strOut}\\n`;\n            mapNewLine();\n            o(parts[i]);\n        }\n    }\n    exports.oWithNewlines = oWithNewlines;\n    const indentStrs = [''];\n    function setIndent() {\n        indentStr = indentStrs[indentAmount];\n        while (indentStr === undefined) {\n            indentStrs.push(`${util_1.last(indentStrs)}\\t`);\n            indentStr = indentStrs[indentAmount];\n        }\n    }\n    function indent() {\n        if (!ugly) {\n            indentAmount = indentAmount + 1;\n            setIndent();\n        }\n    }\n    exports.indent = indent;\n    function unindent() {\n        if (!ugly) {\n            indentAmount = indentAmount - 1;\n            setIndent();\n        }\n    }\n    exports.unindent = unindent;\n    function nl() {\n        if (!ugly) {\n            strOut = `${strOut}\\n${indentStr}`;\n            if (usingSourceMaps)\n                mapNewLine();\n            outColumn = outColumn + indentAmount;\n        }\n    }\n    exports.nl = nl;\n    function mapStr(str) {\n        if (curAst !== lastMappedAst) {\n            const { loc } = curAst;\n            if (Op_1.nonNull(loc)) {\n                sourceMap.addMapping({\n                    source: inFilePath,\n                    original: loc.start,\n                    generated: new Loc_1.Pos(outLine, outColumn)\n                });\n                lastMappedAst = curAst;\n            }\n        }\n        outColumn = outColumn + str.length;\n    }\n    function mapNewLine() {\n        outLine = outLine + 1;\n        outColumn = Loc_1.Pos.start.column;\n        lastMappedAst = null;\n    }\n});\n","import Node from 'esast/lib/Node'\nimport {Pos} from 'esast/lib/Loc'\nimport Op, {nonNull} from 'op/Op'\nimport {SourceMapGenerator} from 'source-map/dist/source-map.min'\nimport {RenderOptions} from '../render'\nimport {last} from './util'\n\n// rendering\nlet strOut: string\nlet indentAmount: number\nlet indentStr: string\n// source maps\nlet usingSourceMaps: boolean\nlet curAst: Node\nlet inFilePath: string\nlet sourceMap: SourceMapGenerator\nlet outLine: number\nlet outColumn: number\nlet lastMappedAst: Op<Node>\n\n// options\nlet ugly: boolean\n\nexport function setUp(options: RenderOptions): void {\n\tugly = Boolean(options.ugly)\n\n\tindentAmount = 0\n\tsetIndent()\n\tstrOut = ''\n\tusingSourceMaps = false\n}\n\nexport function setUpSourceMap(inPath: string, outPath: string): void {\n\tusingSourceMaps = true\n\tinFilePath = inPath\n\tsourceMap = new SourceMapGenerator({file: outPath})\n\toutLine = Pos.start.line\n\toutColumn = Pos.start.column\n\tlastMappedAst = null\n}\n\nexport function finish(): string {\n\tconst _ = strOut\n\tfreeMemory()\n\treturn _\n}\n\nexport function finishWithSourceMap(): {code: string, sourceMap: string} {\n\tconst _ = {code: strOut, sourceMap: sourceMap.toJSON()}\n\tfreeMemory()\n\treturn _\n}\n\nfunction freeMemory(): void {\n\tstrOut = inFilePath = sourceMap = curAst = lastMappedAst = null\n}\n\n/** Set the current Node for source mapping. */\nexport function setAst(_: Node): void {\n\tcurAst = _\n}\n\n// Outputs a string.\n// str may not contain newlines.\nexport function o(str: string): void {\n\tstrOut = strOut + str\n\tif (usingSourceMaps)\n\t\tmapStr(str)\n}\n\nexport function oWithNewlines(str: string): void {\n\tconst parts = str.split('\\n')\n\to(parts[0])\n\tfor (let i = 1; i < parts.length; i = i + 1) {\n\t\tstrOut = `${strOut}\\n`\n\t\tmapNewLine()\n\t\to(parts[i])\n\t}\n}\n\nconst indentStrs = ['']\nfunction setIndent(): void {\n\tindentStr = indentStrs[indentAmount]\n\twhile (indentStr === undefined) {\n\t\tindentStrs.push(`${last(indentStrs)}\\t`)\n\t\tindentStr = indentStrs[indentAmount]\n\t}\n}\n\nexport function indent(): void {\n\tif (!ugly) {\n\t\tindentAmount = indentAmount + 1\n\t\tsetIndent()\n\t}\n}\n\nexport function unindent(): void {\n\tif (!ugly) {\n\t\tindentAmount = indentAmount - 1\n\t\tsetIndent()\n\t}\n}\n\nexport function nl(): void {\n\tif (!ugly) {\n\t\tstrOut = `${strOut}\\n${indentStr}`\n\t\tif (usingSourceMaps)\n\t\t\tmapNewLine()\n\t\toutColumn = outColumn + indentAmount\n\t}\n}\n\nfunction mapStr(str: string): void {\n\tif (curAst !== lastMappedAst) {\n\t\tconst {loc} = curAst\n\t\tif (nonNull(loc)) {\n\t\t\tsourceMap.addMapping({\n\t\t\t\tsource: inFilePath,\n\t\t\t\toriginal: loc.start,\n\t\t\t\tgenerated: new Pos(outLine, outColumn)\n\t\t\t})\n\t\t\tlastMappedAst = curAst\n\t\t}\n\t}\n\toutColumn = outColumn + str.length\n}\n\nfunction mapNewLine(): void {\n\toutLine = outLine + 1\n\toutColumn = Pos.start.column\n\t// Mappings end at end of line. Must begin anew.\n\tlastMappedAst = null\n}\n"],"sourceRoot":"/source/"}